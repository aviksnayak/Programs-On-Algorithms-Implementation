

import java.util.Random;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Name :Avik Nayak 
 * KnapSack Problem Genetic algorithm .
 */


/* this  prints the items with vals and weights*/



//main class

public class KnapsackGA {

	//These are the Input Paramenters that we have to take as input from the user.
	private static int N; //Number of items
	private static int W; //Weight  of the knapsack
	private static int[] ITEMVAL; // This contains the val of each items of individual 
	private static int[] ITEMWT; //his contains the weight of each items of individual
	private static int POPSIZE; //size of the population used for GA
	private static double CROSSRATE; // This is crossover rate for the population 
	private static double MUTRATE; // This is genemutation rate for the population 
	private static int GENEND;//last generation
	
	//output-variables
	private static Knapsack OPTIMUMKNAP; //used to store the latest generations best solution.
	
	private static Random RANDOM = new Random(); //common random object
	
	public static void main(String[] args) {
		try(Scanner scan = new Scanner(System.in)){
			if(N==0 || N<0){
				System.out.print("Number of items: ");
				N = scan.nextInt();
			}
			if(W==0 || W<0){
				System.out.print("Knapsack capacity: ");
				W = scan.nextInt();
			}
			if(ITEMVAL==null || ITEMVAL.length<N || ITEMVAL.length>N
					|| ITEMWT==null || ITEMWT.length<N ||	ITEMWT.length>N){
				if(ITEMVAL==null)
					ITEMVAL = new int[N];
				if(ITEMWT==null)
					ITEMWT = new int[N]; 
				String index = "";
				String vals = "";
				String weights = "";
				//Creating item val-weight list
				for (int i = 0; i < N; i++) {
					index+=i+"\t";
					ITEMVAL[i] = valrand(N*10);
					vals+=ITEMVAL[i]+"\t";
					ITEMWT[i] = valrand(W/2)+1;
					weights+=ITEMWT[i]+"\t";
				}
				System.out.println(index+"\n"+vals+"\n"+weights);
			}
			if(POPSIZE==0 || POPSIZE<0){
				System.out.print("Population size: ");
				POPSIZE = scan.nextInt();
			}
			if(CROSSRATE==0 || CROSSRATE<0){
				System.out.print("Crossover rate: ");
				CROSSRATE = scan.nextDouble();
			}
			if(MUTRATE==0 || MUTRATE<0){
				System.out.print("Genemutation rate: ");
				MUTRATE = scan.nextDouble();
			}
			if(GENEND==0 || GENEND<0){
				System.out.print("Stop after generations: ");
				GENEND = scan.nextInt();
			}
			//create the a initial generation of size POPSIZE
			Population population = new KnapsackGA().new Population(POPSIZE);
			//eval the fitness of initial generation
			population.eval();
			for (int i = 1; i <= GENEND; i++) {
				population.selection();
				population.eval();
			}
			if(OPTIMUMKNAP!=null){
				System.out.println("The best knapsack val/weight is : "+OPTIMUMKNAP.VAL+"/"+OPTIMUMKNAP.WEIGHT);
				System.out.println("Knapsack items: "+(OPTIMUMKNAP.ITEMS!=null?OPTIMUMKNAP.ITEMS.toString():null));
			}else 
				System.out.println("Failed to find the best solution!!!");
		}catch(Exception x){
			x.printStackTrace();
		}
	}


	/**
	 *common method to create random vals
	 *val integer val specifying the limit of random val generated
	 *integer val generated by the nextInt function
	 */


	public static int valrand(int val) {
		 return RANDOM.nextInt(val>0?val:1);
	}



	/**
	 * DNAOBJ object used to create/accept individual items
	 * perform crossover & genemutation on the individual items
	 */


	class Dnaobj{
		String GENES;
		public Dnaobj(String genes) {
			if (genes!=null && !genes.isEmpty())
				this.GENES = genes;
			 else
				this.GENES = geneproduce();
		}


		/**
		 * use to create a new individual , that consist of string of binary digits
		 */

		private String geneproduce() {
			int itemsnumber = KnapsackGA.N;
	        StringBuilder gene = new StringBuilder();
	        gene.setLength(itemsnumber);
	        int weight = 0;
	        int index = KnapsackGA.valrand(itemsnumber);
	        for(int count = 0, i = index; count < itemsnumber;
	        		i=(i+1<itemsnumber?i+1:0),count++) {
	            int val = KnapsackGA.valrand(2);
	            if(val == 1){
	            	weight += KnapsackGA.ITEMWT[i];
	            	if(weight > KnapsackGA.W)
	            		val = 0;
	            }
	            gene.setCharAt(i, String.valOf(val).charAt(0));
	        }
	        return gene.toString();
	    }


		/**
		 * used create a child formed by crossover of current partner with a selected partner passed as argument
		 * crossover of chromosome happens based on the CROSSRATE 
		 * formed by crossover of partners
		 */



		public Dnaobj crossover(Dnaobj partner) {
		    String newGenes="";
		    if (Math.random() < KnapsackGA.CROSSRATE){
			    int crossPoint1 = KnapsackGA.valrand(this.GENES.length());
			    /* one point crossover
			     * newGenes = this.GENES.substring(0,crossPoint1)+
			    		partner.GENES.substring(crossPoint1);*/
			    //Two point crossover
			    int crossPoint2 = KnapsackGA.valrand(this.GENES.length() - crossPoint1) + crossPoint1;
			    newGenes = this.GENES.substring(0,crossPoint1)+
			    		partner.GENES.substring(crossPoint1,crossPoint2)+
			    		this.GENES.substring(crossPoint2);
		    }else
		    	newGenes = partner.GENES;
		    return new Dnaobj(newGenes);
		  }

		/**
		 * used mutate chromosome of current Dnaobj object
		 */

		public void genemutation() {
			if (Math.random() < KnapsackGA.MUTRATE){
				int i = KnapsackGA.valrand(this.GENES.length());
		        this.GENES = this.GENES.substring(0,i)+(this.GENES.charAt(i)==0?1:0)+this.GENES.substring(i+1);
		    }
		 }
	}



	/**
	 * Pupulation is used to Create a specified set of population
	 * finds the fitness & perform selection of the population.
	 */

	class Population {
		private Knapsack[] KNAPSACKS;
		private int SIZEOFPOP;
		private int MAX_FITNESS;
		private ArrayList<Knapsack> OPTIMUMKNAPS = new ArrayList<>();

		public Population(int size){
			this.SIZEOFPOP = size;
			this.KNAPSACKS = new Knapsack[this.SIZEOFPOP];
			for (int i = 0; i < SIZEOFPOP; i++)
				this.KNAPSACKS[i] = new Knapsack();
		}
		/**
		 * Based on the fitness of each object in the population
		 * computes the highest fitness and best objects of the population
		 */
		 public void eval() {
		    for (int i = 0; i < this.SIZEOFPOP; i++) {
		    	if(KNAPSACKS[i].FITNESS<=0)
		    		this.KNAPSACKS[i].Fitnessgen();
		    	if (this.KNAPSACKS[i].FITNESS >= MAX_FITNESS) {
		        this.MAX_FITNESS = this.KNAPSACKS[i].FITNESS;
		        KnapsackGA.OPTIMUMKNAP = this.KNAPSACKS[i];
		        this.OPTIMUMKNAPS.add(this.KNAPSACKS[i]);
		      }
		    }
		  }

		 
		 /**
		  * based on each objects of the population selects individuals for crossover & genemutation
		  */


		  public void selection() {
		    Knapsack[] newKnapsaks = new Knapsack[this.SIZEOFPOP];
		    //use Elitism to SELECT  top twenty % of the best from previous Generation.
		    int top = (int) Math.ceil(this.OPTIMUMKNAPS.size()*.20);
		    int i =0;
		    for (int j=1; j <= top; j++,i++)
		    	newKnapsaks[i] = this.OPTIMUMKNAPS.get(this.OPTIMUMKNAPS.size()-j);
		    for (; i < this.SIZEOFPOP; i++) {
		      Dnaobj parentA = parentselection();
		      Dnaobj parentB = parentselection();
			  Dnaobj child = parentA.crossover(parentB);
			  child.genemutation();
			  newKnapsaks[i] = new Knapsack(child);
		    }
		    //set new population
		    this.KNAPSACKS = newKnapsaks;
		    //reset max_fitnss
		    this.MAX_FITNESS = 0;
		    //reset best set
		    this.OPTIMUMKNAPS.clear();
		  }


		  /**
		   * uses the concept of Roulette wheel to select a partner.
		   * Dnaobj object of the partner selected.
		   */


		  private Dnaobj parentselection() {
			int exitStat = 0;
			while (exitStat<9999) {	
				//Roulette wheel selection
				int index =  KnapsackGA.valrand(this.SIZEOFPOP);
				int val =  KnapsackGA.valrand(this.MAX_FITNESS);
				Knapsack parent = this.KNAPSACKS[index];
				if(val < parent.FITNESS){
					return parent.DNAOBJ;
				}
				exitStat++;
			}
			return this.KNAPSACKS[KnapsackGA.valrand(this.SIZEOFPOP)].DNAOBJ;
		  }
	}


	/**
	 * Represent a knapsack object
	 * calculates fitness of current knapsack object
	 */


	class Knapsack{
		int VAL; 
		int WEIGHT;//used to store the weight of knapsack (WEIGHT<=W), 0 if (WEIGHT>W)
		int FITNESS;
		ArrayList<Integer> ITEMS = new ArrayList<Integer>(); //used to store the items of the knapsack
		Dnaobj DNAOBJ;
		public Knapsack() {
			this.DNAOBJ = new Dnaobj(null);
		}
		public Knapsack(Dnaobj Dnaobj) {
			this.DNAOBJ = Dnaobj;
		}


		/**
		 * calculates the fitness  based on the Dnaobj of the knapsack
		 */


		public void Fitnessgen() {
		    for (int i = 0; i <DNAOBJ.GENES.length() ; i++) {
				if(DNAOBJ.GENES.charAt(i)=='1'){
					ITEMS.add(i);
					this.VAL += KnapsackGA.ITEMVAL[i];
					this.WEIGHT += KnapsackGA.ITEMWT[i];
					if(this.WEIGHT>KnapsackGA.W)
						break;
				}
			}
		    if(this.WEIGHT>KnapsackGA.W||!(this.WEIGHT>0)){
				this.VAL = 0;
				return;
			}
		    this.FITNESS = this.VAL;
		    this.FITNESS = (int) Math.pow(this.FITNESS, 2);
		  }
	}
}




